from fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect
from pydantic import BaseModel
from ..deps import get_current_user
from uuid import uuid4
import asyncio
import json
from typing import Dict, List

router = APIRouter(prefix="/api/v1/chat")

class SessionReq(BaseModel):
    character_id: str

class MessageReq(BaseModel):
    content: str

class RatingReq(BaseModel):
    message_id: str
    rating: int  # 1-5 stars or -1/1 for thumbs

SESSIONS = {}
ACTIVE_CONNECTIONS: Dict[str, WebSocket] = {}

@router.post("/sessions")
def create_session(req: SessionReq, user=Depends(get_current_user)):
    """Create a new chat session with a character"""
    sid = f"sess:{uuid4().hex}"
    SESSIONS[sid] = {
        "id": sid,
        "character_id": req.character_id,
        "user_id": user["user_id"],
        "created_at": "2025-01-15T12:00:00Z",
        "messages": []
    }
    return {"session_id": sid}

@router.post("/sessions/{session_id}/message")
def send_message(session_id: str, req: MessageReq, user=Depends(get_current_user)):
    """Send a message in a chat session"""
    session = SESSIONS.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    if session["user_id"] != user["user_id"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Add user message to session
    user_message = {
        "id": f"msg_{len(session['messages']) + 1}",
        "role": "user",
        "content": req.content,
        "timestamp": "2025-01-15T12:00:00Z",
        "gem_cost": 0
    }
    session["messages"].append(user_message)
    
    # Generate AI response (mock)
    estimated_cost = max(1, len(req.content) // 50)
    ai_response = {
        "id": f"msg_{len(session['messages']) + 1}",
        "role": "assistant",
        "content": f"*responds thoughtfully to your message about '{req.content[:50]}...'* This is a mock AI response that would normally be generated by the character AI model.",
        "timestamp": "2025-01-15T12:00:00Z",
        "gem_cost": estimated_cost
    }
    session["messages"].append(ai_response)
    
    SESSIONS[session_id] = session
    
    return {
        "status": "completed",
        "message_id": ai_response["id"],
        "estimated_cost": estimated_cost,
        "actual_cost": estimated_cost,
        "note": "In production this would stream via WebSocket"
    }

@router.post("/sessions/{session_id}/rate")
def rate_message(session_id: str, req: RatingReq, user=Depends(get_current_user)):
    """Rate an AI message"""
    session = SESSIONS.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    if session["user_id"] != user["user_id"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Find and rate the message
    for message in session["messages"]:
        if message["id"] == req.message_id:
            message["rating"] = req.rating
            message["rated_at"] = "2025-01-15T12:00:00Z"
            break
    
    SESSIONS[session_id] = session
    return {"status": "rated"}

@router.get("/sessions/{session_id}")
def get_session(session_id: str, user=Depends(get_current_user)):
    """Get chat session details and message history"""
    session = SESSIONS.get(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    
    if session["user_id"] != user["user_id"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    return session

@router.get("/sessions")
def list_sessions(user=Depends(get_current_user)):
    """List user's chat sessions"""
    user_sessions = [
        session for session in SESSIONS.values()
        if session["user_id"] == user["user_id"]
    ]
    
    return {"sessions": user_sessions}

@router.websocket("/ws/{session_id}")
async def websocket_chat(websocket: WebSocket, session_id: str):
    """WebSocket endpoint for real-time chat"""
    await websocket.accept()
    ACTIVE_CONNECTIONS[session_id] = websocket
    
    try:
        await websocket.send_text(json.dumps({
            "type": "connection_established",
            "session_id": session_id,
            "message": "Connected to chat session"
        }))
        
        while True:
            # Wait for messages from client
            data = await websocket.receive_text()
            try:
                message_data = json.loads(data)
                
                if message_data.get("type") == "message":
                    # Mock streaming response
                    content = message_data.get("content", "")
                    
                    # Send acknowledgment
                    await websocket.send_text(json.dumps({
                        "type": "message_received",
                        "content": content
                    }))
                    
                    # Simulate AI thinking
                    await websocket.send_text(json.dumps({
                        "type": "ai_thinking",
                        "message": "AI is generating response..."
                    }))
                    
                    # Simulate streaming AI response
                    ai_response = f"*responds to your message about '{content[:30]}...'* This is a streaming AI response that would be generated token by token."
                    
                    for i, char in enumerate(ai_response):
                        await websocket.send_text(json.dumps({
                            "type": "ai_token",
                            "token": char,
                            "position": i
                        }))
                        await asyncio.sleep(0.05)  # Simulate typing delay
                    
                    # Send completion
                    await websocket.send_text(json.dumps({
                        "type": "ai_complete",
                        "message_id": f"msg_{session_id}_{len(SESSIONS.get(session_id, {}).get('messages', []))}",
                        "gem_cost": max(1, len(content) // 50)
                    }))
                    
            except json.JSONDecodeError:
                await websocket.send_text(json.dumps({
                    "type": "error",
                    "message": "Invalid JSON format"
                }))
                
    except WebSocketDisconnect:
        if session_id in ACTIVE_CONNECTIONS:
            del ACTIVE_CONNECTIONS[session_id]
